# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# .github/workflows/ci.yml
#
# FONCTIONNEMENT GÃ‰NÃ‰RAL :
#
#   Chaque push ou PR dÃ©clenche ce pipeline composÃ© de 3 jobs exÃ©cutÃ©s
#   dans l'ordre suivant (grÃ¢ce au mot-clÃ© "needs") :
#
#   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”‚  lint   â”‚â”€â”€â”€â”€â–¶â”‚ integration-tests  â”‚â”€â”€â”€â”€â–¶â”‚ compliance-reportâ”‚
#   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
#   Si "lint" Ã©choue â†’ "integration-tests" ne dÃ©marre pas
#   Si "integration-tests" Ã©choue â†’ "compliance-report" ne dÃ©marre pas
#
# POURQUOI KIND FONCTIONNE SUR GITHUB ACTIONS SANS CONFIGURATION SPÃ‰CIALE :
#
#   GitHub Actions fournit une VM Ubuntu dÃ©diÃ©e par job (runs-on: ubuntu-latest)
#   Cette VM a Docker prÃ©-installÃ© et configurÃ©.
#   Kind crÃ©e ses "nÅ“uds" Kubernetes sous forme de containers Docker directement
#   sur cette VM â†’ pas besoin de Docker-in-Docker (DinD) ni de privileged mode.
#
#   Contrairement Ã  GitLab CI oÃ¹ le job tourne dans un container,
#   ici le job tourne dans une vraie VM â†’ Docker est disponible nativement.
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: PSA Lab CI

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DÃ‰CLENCHEURS
# Le pipeline se lance automatiquement dans ces situations :
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
on:
  push:
    branches:
      - main       # Chaque push sur main (ex: merge d'une PR)
      - develop    # Chaque push sur develop (branche de dÃ©veloppement)
  pull_request:
    branches:
      - main       # Chaque PR qui cible main (avant le merge)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VARIABLES D'ENVIRONNEMENT GLOBALES
# Accessibles dans tous les jobs via ${{ env.NOM_VARIABLE }}
# CentralisÃ©es ici pour faciliter les mises Ã  jour de version
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
env:
  KIND_VERSION: v0.20.0       # Version de Kind Ã  installer sur la VM
  KUBECTL_VERSION: v1.28.0    # Version de kubectl (doit correspondre au cluster)
  # Nom unique par run pour Ã©viter les conflits si plusieurs pipelines tournent en parallÃ¨le
  # github.run_id est un entier unique gÃ©nÃ©rÃ© par GitHub pour chaque exÃ©cution
  CLUSTER_NAME: psa-ci-${{ github.run_id }}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# JOB 1 : LINT
# Objectif : vÃ©rifier la syntaxe des fichiers YAML et du chart Helm
#            AVANT de crÃ©er un cluster (rapide et peu coÃ»teux)
# DurÃ©e estimÃ©e : ~30 secondes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
jobs:
  lint:
    name: "Lint YAML & Helm"
    runs-on: ubuntu-latest   # VM Ubuntu fournie par GitHub (2 CPU, 7 Go RAM)

    steps:
      # â”€â”€ RÃ©cupÃ©rer le code du repo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # actions/checkout est l'action officielle GitHub pour cloner le repo
      # dans le workspace de la VM (/home/runner/work/<repo>/<repo>)
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ Installer yamllint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # yamllint est un linter Python pour la syntaxe YAML
      # Il dÃ©tecte les erreurs d'indentation, les tabulations, etc.
      - name: Install yamllint
        run: pip install yamllint

      # â”€â”€ Linter les fichiers YAML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # -d relaxed : mode permissif (pas de rÃ¨gles strictes sur la longueur des lignes)
      # || true : ne pas faire Ã©chouer le job sur les warnings (non-bloquant)
      # On lint manifests/ et kind/ mais pas helm/ (templates Helm contiennent {{ }})
      - name: Lint YAML
        run: yamllint -d relaxed manifests/ kind/ || true

      # â”€â”€ Installer Helm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # azure/setup-helm est l'action recommandÃ©e pour installer Helm sur la VM
      # On fixe la version pour Ã©viter les surprises lors des mises Ã  jour
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.13.0

      # â”€â”€ Linter le chart Helm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # helm lint vÃ©rifie la structure du chart :
      #   - Chart.yaml valide
      #   - templates syntaxiquement corrects
      #   - values.yaml cohÃ©rent
      # --strict : traiter les warnings comme des erreurs (plus rigoureux)
      - name: Lint Helm chart
        run: |
          helm lint ./helm/psa-namespace --strict
          echo "âœ… Helm lint OK"

      # â”€â”€ Tester le rendu des templates Helm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # helm template gÃ©nÃ¨re les manifests YAML finaux sans les appliquer
      # Cela vÃ©rifie que les templates se rendent correctement avec des valeurs
      # C'est diffÃ©rent de helm lint : ici on teste le rendu rÃ©el
      - name: Helm template dry-run
        run: |
          helm template test-ns ./helm/psa-namespace \
            --set namespaceName=helm-test \
            --set podSecurity.enforce=restricted \
            --set podSecurity.version=v1.28
          echo "âœ… Helm template OK"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2 : TESTS D'INTÃ‰GRATION
  # Objectif : crÃ©er un vrai cluster Kubernetes avec Kind et exÃ©cuter
  #            les tests PSA pour valider que tout fonctionne end-to-end
  # DurÃ©e estimÃ©e : ~3-4 minutes (la majoritÃ© en crÃ©ation du cluster)
  # DÃ©pendance : attend que "lint" rÃ©ussisse avant de dÃ©marrer
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  integration-tests:
    name: "PSA Integration Tests (Kind)"
    runs-on: ubuntu-latest
    needs: lint   # â† Ce job ne dÃ©marre QUE si "lint" a rÃ©ussi (exit 0)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ CrÃ©er le cluster Kind â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # helm/kind-action est l'action officielle pour Kind sur GitHub Actions
      # Elle :
      #   1. TÃ©lÃ©charge et installe Kind (version spÃ©cifiÃ©e)
      #   2. TÃ©lÃ©charge et installe kubectl (version spÃ©cifiÃ©e)
      #   3. CrÃ©e le cluster avec la config fournie
      #   4. Configure automatiquement le kubeconfig pour que kubectl fonctionne
      #
      # config: kind/cluster-simple.yaml â†’ 1 seul nÅ“ud (plus rapide en CI)
      #   On n'utilise pas cluster-multinode.yaml pour Ã©conomiser du temps CI
      #
      # wait: 120s â†’ attendre jusqu'Ã  2 minutes que les nÅ“uds soient Ready
      #   Sans ce paramÃ¨tre, les Ã©tapes suivantes pourraient Ã©chouer car
      #   les pods systÃ¨me (coredns, etc.) ne seraient pas encore dÃ©marrÃ©s
      - name: Setup Kind + kubectl
        uses: helm/kind-action@v1
        with:
          version: ${{ env.KIND_VERSION }}
          cluster_name: ${{ env.CLUSTER_NAME }}
          config: kind/cluster-simple.yaml
          kubectl_version: ${{ env.KUBECTL_VERSION }}
          wait: 120s

      # â”€â”€ VÃ©rifier que le cluster rÃ©pond â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Ã‰tape de diagnostic : si quelque chose se passe mal plus tard,
      # ces infos dans les logs aident Ã  comprendre l'Ã©tat du cluster
      # --context kind-<nom> : Ãªtre explicite sur quel cluster on parle
      #   (utile si plusieurs kubeconfigs sont prÃ©sents)
      - name: Verify cluster is ready
        run: |
          kubectl cluster-info --context kind-${{ env.CLUSTER_NAME }}
          kubectl get nodes -o wide
          kubectl get pods -A   # VÃ©rifier que les pods systÃ¨me tournent

      # â”€â”€ Installer jq â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # jq est un outil de parsing JSON utilisÃ© dans nos scripts bash
      # (audit-namespaces.sh et check-compliance.sh l'utilisent)
      # Il est prÃ©-installÃ© sur les runners GitHub mais on s'assure qu'il est lÃ 
      - name: Install jq
        run: sudo apt-get install -y jq

      # â”€â”€ Rendre les scripts exÃ©cutables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Git ne prÃ©serve pas toujours les permissions +x sur les fichiers
      # Cette Ã©tape garantit que tous les scripts .sh sont exÃ©cutables
      - name: Make scripts executable
        run: chmod +x scripts/*.sh tests/*.sh

      # â”€â”€ Tests Lab 1 : Profil Privileged â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # VÃ©rifie que :
      #   - le namespace monitoring-privileged a les bons labels PSA
      #   - les workloads avec hostNetwork/hostPID sont acceptÃ©s
      #   - l'exception est documentÃ©e via annotations
      - name: Run Lab 1 tests (Privileged)
        run: ./tests/test-lab1-privileged.sh

      # â”€â”€ Tests Lab 2 : Profil Baseline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # VÃ©rifie que :
      #   - le namespace app-baseline a enforce=baseline
      #   - les pods conformes sont crÃ©Ã©s
      #   - les pods avec hostNetwork sont REFUSÃ‰S
      #   - les warnings restricted s'affichent bien
      - name: Run Lab 2 tests (Baseline)
        run: ./tests/test-lab2-baseline.sh

      # â”€â”€ Tests Lab 3 : Profil Restricted â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # VÃ©rifie que :
      #   - le namespace app-restricted a enforce=restricted
      #   - les pods sans seccomp/capabilities/runAsNonRoot sont REFUSÃ‰S
      #   - les pods correctement configurÃ©s sont crÃ©Ã©s
      #   - les champs de sÃ©curitÃ© sont bien prÃ©sents dans le pod crÃ©Ã©
      - name: Run Lab 3 tests (Restricted)
        run: ./tests/test-lab3-restricted.sh

      # â”€â”€ Rapport d'audit des namespaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Affiche un tableau rÃ©capitulatif de tous les namespaces
      # avec leurs politiques PSA enforce/audit/warn
      # Utile pour avoir une vue d'ensemble dans les logs CI
      - name: Audit all namespaces
        run: ./scripts/audit-namespaces.sh

      # â”€â”€ Dry-run server-side de tous les namespaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # --server-side : la validation se fait cÃ´tÃ© API server (plus prÃ©cise)
      # --dry-run=server : simule l'apply sans rien crÃ©er/modifier
      # Cela dÃ©tecte les erreurs que le client-side dry-run ne verrait pas
      # (ex: conflits, validations webhooks, etc.)
      - name: Dry-run namespaces server-side
        run: |
          kubectl apply -f manifests/00-namespaces/ --server-side --dry-run=server
          echo "âœ… Dry-run namespaces OK"

      # â”€â”€ Installer Helm pour le dry-run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Helm n'est pas partagÃ© entre les jobs (chaque job a sa propre VM)
      # Il faut le rÃ©installer dans ce job
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.13.0

      # â”€â”€ Tester le chart Helm contre un vrai cluster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # helm install --dry-run --debug contre un vrai cluster (pas juste template)
      # Cela vÃ©rifie que Helm peut communiquer avec l'API server
      # et que les ressources gÃ©nÃ©rÃ©es sont valides selon Kubernetes
      # --debug : affiche le manifest YAML gÃ©nÃ©rÃ© dans les logs (pratique)
      - name: Helm install dry-run
        run: |
          helm install test-ns ./helm/psa-namespace \
            --set namespaceName=helm-test \
            --set podSecurity.enforce=restricted \
            --set podSecurity.version=v1.28 \
            --dry-run --debug
          echo "âœ… Helm dry-run OK"

      # â”€â”€ Collecter les logs en cas d'Ã©chec â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # if: failure() â†’ cette Ã©tape ne s'exÃ©cute QUE si une Ã©tape prÃ©cÃ©dente
      #   a Ã©chouÃ© (exit code != 0)
      # Les logs Kind sont utiles pour diagnostiquer les problÃ¨mes de cluster
      # L'artifact est disponible dans l'onglet "Summary" du workflow pendant 3 jours
      - name: Upload logs si Ã©chec
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: kind-logs-${{ github.run_id }}
          path: /tmp/kind-logs/
          retention-days: 3

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3 : RAPPORT DE CONFORMITÃ‰
  # Objectif : gÃ©nÃ©rer un tableau rÃ©capitulatif visible dans l'onglet
  #            "Summary" du workflow sur GitHub (pas dans les logs)
  # DurÃ©e estimÃ©e : ~10 secondes
  # Condition : uniquement sur la branche main (pas sur les PR)
  #             car c'est un rapport "officiel" de l'Ã©tat de la branche stable
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  compliance-report:
    name: "Compliance Report"
    runs-on: ubuntu-latest
    needs: integration-tests   # â† Attend que les tests passent

    # if: github.ref == 'refs/heads/main'
    # Ce job ne tourne PAS sur les PR, seulement aprÃ¨s merge sur main
    # Sur une PR, refs/heads/main ne correspond pas (c'est refs/pull/N/merge)
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ GÃ©nÃ©rer le rapport de conformitÃ© â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # $GITHUB_STEP_SUMMARY est une variable GitHub Actions qui pointe vers
      # un fichier Markdown spÃ©cial : tout ce qu'on Ã©crit dedans apparaÃ®t
      # dans l'onglet "Summary" du workflow (interface graphique GitHub)
      # C'est diffÃ©rent des logs : c'est mis en forme et mis en avant
      #
      # Le script :
      #   1. Parse chaque fichier YAML de manifests/00-namespaces/
      #   2. Extrait les labels PSA avec grep + awk
      #   3. Ajoute un emoji selon le niveau (ğŸŸ¢ restricted, ğŸŸ¡ baseline, ğŸ”´ privileged)
      #   4. Construit un tableau Markdown
      - name: Generate compliance summary
        run: |
          echo "## ğŸ” PSA Compliance Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | Enforce | Audit | Warn |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|:-------:|:-----:|:----:|" >> $GITHUB_STEP_SUMMARY
          find manifests/00-namespaces/ -name '*.yaml' | sort | while read f; do
            NS=$(grep "name:" "$f" | head -1 | awk '{print $2}')
            ENF=$(grep "enforce:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            AUD=$(grep "audit:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            WRN=$(grep "warn:" "$f" | grep -v "version" | head -1 | awk '{print $2}' || echo "N/A")
            case "$ENF" in
              restricted)  ICON="ğŸŸ¢" ;;
              baseline)    ICON="ğŸŸ¡" ;;
              privileged)  ICON="ğŸ”´" ;;
              *)           ICON="âšª" ;;
            esac
            echo "| \`$NS\` | $ICON $ENF | $AUD | $WRN |" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Pipeline complet â€” tous les tests ont passÃ©" >> $GITHUB_STEP_SUMMARY
